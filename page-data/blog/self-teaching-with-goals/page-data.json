{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/blog//self-teaching-with-goals/","result":{"data":{"markdownRemark":{"id":"74458cac-4245-52b7-b815-3e54d9b7a734","excerpt":"I started programming in elementary school, and as an adult I’ve met others who did the same. But one critical difference I see between myself and many of them…","html":"<p>I started programming in elementary school, and as an adult I’ve met others who did the same. But one critical difference I see between myself and many of them is what we have to show for all those years of experience. I’m not even talking about portfolios - I don’t show any of my old work to anyone. I’m talking about knowledge and skills that self-taught programmers can use in their day jobs.</p>\n<p>And I think I know why. The key difference in our self-taught experience is that I built a large project with complex features, and fixed many difficult bugs in it, all over the course of several years. Focusing on that large project had a lot of positive effects:</p>\n<ul>\n<li>It required me to <em>live</em> in a codebase, rather than just create and forget about one. If you build some small-sized (read: typical) project as a self-taught developer, you won’t discover many architectural mistakes you make. Many organizational and architectural decisions that <em>seem</em> great will work fine in small projects, but in a larger-scale project you’d easily see (and <em>feel</em>) their drawbacks</li>\n<li>It required me to <em>plan</em> in far greater detail. I couldn’t just write code, I had to conciously think about the repercussions of code, and figure out what was the best way to do something. I would be living with whatever decision I made for a while, so it was important to make it be the right one the first time</li>\n<li>It required me to <em>keep production working well</em>. For example, I once migrated all the data in one database to another database, with very minimal downtime. In a smaller, less serious project, I could have just said “who cares about migrating the data” and would not have learned anywhere near as much about the perils of data migrations.</li>\n<li>It required me to <em>care about security and privacy</em>. For example, I needed to have geographic redundancy, and the service providers I was using didn’t provide VPNs at the time, so I needed to learn SSH tunnelling. Even this year I had to use SSH tunnelling several times for work to forward ports from one machine to another - something I wouldn’t even know was possible if I was only working on smaller projects, where things like security and privacy are often as simple as “don’t save any user input on a server”</li>\n<li>It would later demonstrate to people reading my resume that I didn’t just work on little toy applications that could be accomplished without much skill, but that my work was far more complex, and demanded much more</li>\n</ul>\n<p>If you build a large project that you treat as a real product (note that <strong>it doesn’t need to even be a real product</strong>, you just have to treat it as seriously as if it were), it will improve your skills more than 100 small projects will teach you. Sure, then 100 small projects can teach you a wide variety of things, but that 1 project can teach you immensely valuable lessons you can then apply to projects of any size later on.</p>\n<p>Here’s a <strong>concrete example</strong>. Imagine you build a simple “todo list” that stores the items in an array of strings, allowing you to only add strings to it. And now imagine you want to add the ability to actually put a checkmark by todos instead of just deleting them. Many self-taught programmers create an parallel array of booleans to handle this, and it works for them. If you were to treat this as a real product, you’d add features like deleting todos, reordering todos, persisting todos to some database, adding todo creation times, maybe even todo authors and sharing functionality, etc. As you built these features, you’d notice some things:</p>\n<ul>\n<li>Peresisting the todos to a database will typically involve serializing the parallel arrays into a single array with both of those things combined into each element of the array, and deserializing back into parallel arrays for the UI</li>\n<li>As you add on things to store about todos (creation date, user who created them, etc), you wind up creating more parallel arrays that you must now also add to serialization and deserialization</li>\n<li>Many features require manipulating more than 1 of the parallel arrays. For example, if you add deletion, you need to go into each of the parallel arrays and delete the right element from them. And if you implement reordering todos, then you also need to delete from each of the parallel arrays. Note that this interacts with the previous point in such a way that you can easily end up with tons of repeated code, and can have subtle failure cases if you miss even 1 line of code (or forget to update just 1 line of code)</li>\n<li>When you write code for working with a todo in another UI view, you may start using todos the way they’re stored in the database, so now you have 2 different ways of representing a todo even in your UI, which make it hard to reuse code between those two different UIs. For example, one needs serialization/deserialization, while the other does not. Or as another example, one may operate on an entire array with an index, while the other operates on an object</li>\n<li>All of the above doesn’t just slow you down, but also feels increasingly “unhygenic”, making you want to rewrite the parallel arrays (which also takes time and effort)</li>\n</ul>\n<p>Working on a larger project, you’d learn that the parallel array idea isn’t a good fit for this use case. But in a smaller project that you didn’t really treat as a product (like the original, simple todo list), you may not realize any of the above issues could occur. Even in a larger-than-average project, you may still not encounter some of the above issues, or may underestimate the severity of them.</p>\n<p>Even this tiny design decision can have a very negative effect in a large codebase. Just imagine how many other decisions there are to learn from, that you’ll never learn in projects that are smaller or that you don’t take as seriously.</p>","frontmatter":{"title":"Self-teaching with goals","date":"April 29, 2021","description":"As a self-taught programmer, the biggest tip that I have to others looking to become self-taught programmers is to work on fewer, larger projects, and treat them like real businesses. While experimentation and learning the basics are both helpful, they simply won't provide you with many real-world challenges."}},"previous":null,"next":null},"pageContext":{"id":"74458cac-4245-52b7-b815-3e54d9b7a734","previousPostId":null,"nextPostId":null}},"staticQueryHashes":["3000541721"]}